11.6



cd apps/api
python -m venv .venv
.venv\Scripts\activate
pip install -r requirements.txt
uvicorn app.main:app --reload --host 127.0.0.1 --port 8000



cd apps/api
.venv\Scripts\activate
uvicorn app.main:app --reload --host 127.0.0.1 --port 8000





http://127.0.0.1:3002/docs





cd apps/web
pnpm install
pnpm dev







请你先详细地重新扫描一遍代码库，我自己又更改了一些代码逻辑。短答：**不用把前端完全定死再做后端**。最稳的是**“契约优先 + 纵向切片（vertical slice）”**：先把“数据与接口约定”敲定，再做一条最小闭环，从上传到产出跑通；之后再细化 UI 与效果。

\# 建议路线（精简版）

1. **锁定单一核心流程（你的产品）**

   上传 PDF 简历 → 确认公司/岗位（抓 JD）→ 一键产出 **简历草稿 + 面试问题 + 知识点** → 在编辑器里可二次修改与保存版本。

2. **契约优先（先定数据形状与接口，不是先定像素）**

   先写清 3 个对象与字段：

\* `Resume`: id, raw_text, parsed_blocks[], skills[], contacts{}

\* `JD`: id, company, title, jd_text, must_have_skills[], nice_to_have[]

\* `Output`: id, resume_md, interview_questions[], knowledge_items[]（title,url,why）

  以及状态：`task_id`, `status` = queued|running|done|error, `cost`, `latency`.

3. **起一个“假后端/Mock”让前端先跑**

\* 用 **MSW** 或 Next.js 的 `/api/*` 先返回固定 JSON。

\* 前端根据契约开发页签和状态（Skeleton/Loading/Empty/Error）。

\* LLM 先用模板/假数据，等闭环跑通后再接真模型。

4. **做一条纵向切片（1~2 天可落地）**

\* 页面已有：上传区、JD 确认侧栏、编辑区、输出面板。

\* 接口（示例，够用即可）：

  \* `POST /api/resumes` → `{resume_id}`

  \* `POST /api/jds/parse`（url或文本）→ `{jd_id, company, title, skills[]}`

  \* `POST /api/pipelines/run`（resume_id, jd_id）→ `{task_id}`

  \* `GET /api/tasks/{id}` → `{status, output}`（含 `resume_md`, `interview_questions`, `knowledge_items`）

\* 前端只关心这四个契约，后端实现可逐步替换。

5. **再接真后端**

\* **模型层**：用统一的 `LLMProvider` 适配器封装 Qwen/DeepSeek（后续可换 GPT 也不改前端）。

\* **任务层**：长时任务走队列（如轻量 BullMQ）或轮询上面的 `GET /tasks/{id}`。

\* **存储**：SQLite/PG + Prisma（版本化保存 `resume_md` 和 diff）。

\* **观测**：Sentry/日志 + 成本统计（每次调用记录 tokens/￥）。

6. **UI 与交互打磨**（并行迭代而非一次性定死）

\* 先出低保真线框和组件清单（按钮/卡片/面板/编辑器）。

\* 把动效与光效当“皮肤”层放设计令牌（颜色、圆角、阴影）里，避免改一次动效就牵动业务代码。

\* 像 TipTap 这类纯客户端组件：`dynamic(import(...), { ssr:false })`，并确保 `immediatelyRender:false`，避免你碰到的 SSR hydration 报错。

\# 你现在可以立刻做的三件小事

\* 写一个 **README/接口草案**（上面 4 个 API + 字段表）。

\* 在现有页面里**用 Mock** 跑通“上传→跑任务→展示三项结果”的闭环。

\* 把 LLM 调用与持久化各自封装成服务，前端只拿统一的 JSON。

这样做的好处：

\* 降低返工（UI 不会被数据结构“打脸”）。

\* 很快有“能用的最小版本”给朋友内测。

\* 后端可替换与扩展（模型、数据库、队列）而不影响前端。

需要的话，我可以直接把这四个接口的 **OpenAPI 草案** 和 **前端 Mock 代码片段** 给你，照抄即跑通闭环。

请你现在开始实现这四个最小的后端功能



# 0. 使用方式（2 分钟跑通）

- 技术栈假设：**Next.js 14/15/16（App Router） + TypeScript**，前端已存在页面。
- 把本文档中的 **OpenAPI**、**TS 类型**、**Next API 路由（Mock）**、**前端 hooks** 依次复制到项目即可形成“上传→解析 JD→跑任务→拿结果”的闭环。
- 先用 **内存 Mock** 跑通，后续再替换为真后端/数据库/队列。

------

# 1) OpenAPI 3.1 契约（最小可用）

> 保存为 `openapi.yml`，便于后续生成 SDK / 校验。

```yaml
openapi: 3.1.0
info:
  title: Resume Copilot API
  version: 0.1.0
servers:
  - url: /api
paths:
  /resumes:
    post:
      summary: 上传简历（PDF/Doc/纯文本）并解析为结构化字段
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
                text:
                  type: string
                  description: 备用：若无文件，直接上传纯文本
      responses:
        '200':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Resume'
  /jds/parse:
    post:
      summary: 解析 JD（支持 URL 或原文）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                url: { type: string }
                text: { type: string }
      responses:
        '200':
          description: Parsed JD
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/JD'
  /pipelines/run:
    post:
      summary: 运行主流程（简历×JD → 简历草稿 + 面试题 + 知识点）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [resume_id, jd_id]
              properties:
                resume_id: { type: string }
                jd_id: { type: string }
      responses:
        '200':
          description: Task queued
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Task'
  /tasks/{id}:
    get:
      summary: 轮询任务状态
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Task status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Task'
components:
  schemas:
    Resume:
      type: object
      required: [id, raw_text]
      properties:
        id: { type: string }
        raw_text: { type: string }
        parsed_blocks:
          type: array
          items:
            type: object
            properties:
              type: { type: string, enum: [header, education, experience, project, skills] }
              text: { type: string }
        skills:
          type: array
          items: { type: string }
        contacts:
          type: object
          properties:
            name: { type: string }
            email: { type: string }
            phone: { type: string }
    JD:
      type: object
      required: [id, company, title, jd_text]
      properties:
        id: { type: string }
        company: { type: string }
        title: { type: string }
        jd_text: { type: string }
        must_have_skills:
          type: array
          items: { type: string }
        nice_to_have:
          type: array
          items: { type: string }
    KnowledgeItem:
      type: object
      properties:
        title: { type: string }
        url: { type: string }
        why: { type: string }
    Output:
      type: object
      required: [id, resume_md, interview_questions, knowledge_items]
      properties:
        id: { type: string }
        resume_md: { type: string }
        interview_questions:
          type: array
          items: { type: string }
        knowledge_items:
          type: array
          items: { $ref: '#/components/schemas/KnowledgeItem' }
    Task:
      type: object
      required: [id, status]
      properties:
        id: { type: string }
        status: { type: string, enum: [queued, running, done, error] }
        cost: { type: number, nullable: true }
        latency_ms: { type: integer, nullable: true }
        output: { $ref: '#/components/schemas/Output' }
        error: { type: string, nullable: true }
```

------

# 2) TypeScript 类型 & Zod 校验（`/lib/types.ts`）

```ts
import { z } from "zod";

export const ResumeBlockSchema = z.object({
  type: z.enum(["header", "education", "experience", "project", "skills"]),
  text: z.string(),
});

export const ResumeSchema = z.object({
  id: z.string(),
  raw_text: z.string(),
  parsed_blocks: z.array(ResumeBlockSchema).default([]),
  skills: z.array(z.string()).default([]),
  contacts: z
    .object({ name: z.string().optional(), email: z.string().optional(), phone: z.string().optional() })
    .default({}),
});
export type Resume = z.infer<typeof ResumeSchema>;

export const JDSchema = z.object({
  id: z.string(),
  company: z.string(),
  title: z.string(),
  jd_text: z.string(),
  must_have_skills: z.array(z.string()).default([]),
  nice_to_have: z.array(z.string()).default([]),
});
export type JD = z.infer<typeof JDSchema>;

export const KnowledgeItemSchema = z.object({ title: z.string(), url: z.string(), why: z.string() });
export type KnowledgeItem = z.infer<typeof KnowledgeItemSchema>;

export const OutputSchema = z.object({
  id: z.string(),
  resume_md: z.string(),
  interview_questions: z.array(z.string()),
  knowledge_items: z.array(KnowledgeItemSchema),
});
export type Output = z.infer<typeof OutputSchema>;

export const TaskSchema = z.object({
  id: z.string(),
  status: z.enum(["queued", "running", "done", "error"]),
  cost: z.number().nullable().optional(),
  latency_ms: z.number().nullable().optional(),
  output: OutputSchema.optional(),
  error: z.string().nullable().optional(),
});
export type Task = z.infer<typeof TaskSchema>;
```

------

# 3) 内存数据 & 工具函数（`/lib/store.ts`）

```ts
import { JD, JDSchema, Output, OutputSchema, Resume, ResumeSchema, Task } from "./types";

const mem = {
  resumes: new Map<string, Resume>(),
  jds: new Map<string, JD>(),
  tasks: new Map<string, Task>(),
  outputs: new Map<string, Output>(),
};

const rid = () => Math.random().toString(36).slice(2, 10);

export function saveResume(raw_text: string): Resume {
  const r: Resume = ResumeSchema.parse({ id: `r_${rid()}`, raw_text, parsed_blocks: [], skills: [], contacts: {} });
  mem.resumes.set(r.id, r);
  return r;
}

export function saveJD(input: Partial<JD> & { jd_text: string }): JD {
  const j: JD = JDSchema.parse({
    id: `j_${rid()}`,
    company: input.company ?? "Unknown Co.",
    title: input.title ?? "Unknown Title",
    jd_text: input.jd_text,
    must_have_skills: extractSkills(input.jd_text).must,
    nice_to_have: extractSkills(input.jd_text).nice,
  });
  mem.jds.set(j.id, j);
  return j;
}

export function createTask(resume_id: string, jd_id: string): Task {
  const t: Task = { id: `t_${rid()}`, status: "queued" };
  mem.tasks.set(t.id, t);
  // 模拟异步流水线
  setTimeout(() => {
    t.status = "running";
    setTimeout(() => {
      const out = synthesizeOutput(resume_id, jd_id);
      mem.outputs.set(out.id, out);
      t.status = "done";
      (t as any).output = out;
      (t as any).latency_ms = 1500 + Math.floor(Math.random() * 800);
      (t as any).cost = Number((Math.random() * 0.08 + 0.02).toFixed(3));
    }, 1200);
  }, 300);
  return t;
}

export function getTask(id: string): Task | undefined {
  return mem.tasks.get(id);
}

// —— 朴素技能抽取 ——
function extractSkills(text: string) {
  const must: string[] = [];
  const nice: string[] = [];
  const dict = ["Python", "Go", "Java", "TypeScript", "MySQL", "Redis", "LLM", "LangChain", "OpenAI", "Qwen", "DeepSeek", "CV", "NLP"];
  dict.forEach((k) => (text.toLowerCase().includes(k.toLowerCase()) ? must.push(k) : null));
  return { must, nice };
}

// —— 生成假结果（可替换为真实 LLM） ——
function synthesizeOutput(resume_id: string, jd_id: string): Output {
  const r = mem.resumes.get(resume_id);
  const j = mem.jds.get(jd_id);
  const id = `o_${rid()}`;
  const resume_md = `# 优化后简历（面向 ${j?.company}·${j?.title}）\n\n- 关键技能匹配：${j?.must_have_skills.slice(0, 5).join(", ")}\n- 量化成果：示例）将 DAU 提升 **+12%**，故障率 **-30%**。`;
  const interview_questions = [
    "请详细阐述你在项目中如何将指标提升 12% 的具体实验设计与对照组选择？",
    "针对岗位要求中的 Redis 与 MySQL，谈谈你做过的高并发读写优化。",
    "如果要把你的项目迁移到公司现有栈，最大的技术风险是什么？",
  ];
  const knowledge_items = [
    { title: "B 站｜A/B 测试入门", url: "https://www.bilibili.com/", why: "岗位强调增长实验能力" },
    { title: "B 站｜MySQL 索引与事务", url: "https://www.bilibili.com/", why: "JD 明确要求数据库优化" },
    { title: "B 站｜Redis 实战", url: "https://www.bilibili.com/", why: "常见面试追问点：缓存穿透/击穿/雪崩" },
  ];
  return OutputSchema.parse({ id, resume_md, interview_questions, knowledge_items });
}
```

------

# 4) Next.js API 路由（Mock 可直接用）

> 目录：`/app/api/*/route.ts`

## 4.1 `/api/resumes` — POST

```ts
// app/api/resumes/route.ts
import { NextRequest, NextResponse } from "next/server";
import { saveResume } from "@/lib/store";

export async function POST(req: NextRequest) {
  const ct = req.headers.get("content-type") || "";
  if (ct.includes("multipart/form-data")) {
    const fd = await req.formData();
    const file = fd.get("file") as File | null;
    const text = (fd.get("text") as string) || "";
    const raw = text || (file ? await file.text() : "");
    const res = saveResume(raw || "EMPTY_RESUME_TEXT");
    return NextResponse.json(res);
  } else {
    const body = await req.json().catch(() => ({}));
    const raw = body.text || "";
    const res = saveResume(raw || "EMPTY_RESUME_TEXT");
    return NextResponse.json(res);
  }
}
```

## 4.2 `/api/jds/parse` — POST

```ts
// app/api/jds/parse/route.ts
import { NextRequest, NextResponse } from "next/server";
import { saveJD } from "@/lib/store";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { url, text } = body || {};
  const jdText = text || (url ? `JD from ${url}: 负责后端开发，要求：Go/Redis/MySQL/LLM` : "");
  const jd = saveJD({ jd_text: jdText, company: "ByteDance", title: "后端开发工程师" });
  return NextResponse.json(jd);
}
```

## 4.3 `/api/pipelines/run` — POST

```ts
// app/api/pipelines/run/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createTask } from "@/lib/store";

export async function POST(req: NextRequest) {
  const { resume_id, jd_id } = await req.json();
  if (!resume_id || !jd_id) {
    return NextResponse.json({ message: "resume_id & jd_id required" }, { status: 400 });
  }
  const task = createTask(resume_id, jd_id);
  return NextResponse.json(task);
}
```

## 4.4 `/api/tasks/[id]` — GET

```ts
// app/api/tasks/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getTask } from "@/lib/store";

export async function GET(_req: NextRequest, { params }: { params: { id: string } }) {
  const t = getTask(params.id);
  if (!t) return NextResponse.json({ message: "task not found" }, { status: 404 });
  return NextResponse.json(t);
}
```

------

# 5) 前端调用 hooks（SWR/简单轮询）

> 目录：`/lib/hooks.ts`

```ts
import useSWR from "swr";

const fetcher = (url: string) => fetch(url).then((r) => r.json());

export async function uploadResume(input: { file?: File; text?: string }) {
  if (input.file) {
    const fd = new FormData();
    fd.append("file", input.file);
    return fetch("/api/resumes", { method: "POST", body: fd }).then((r) => r.json());
  }
  return fetch("/api/resumes", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ text: input.text || "" }),
  }).then((r) => r.json());
}

export async function parseJD(input: { url?: string; text?: string }) {
  return fetch("/api/jds/parse", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(input) }).then((r) => r.json());
}

export async function runPipeline(resume_id: string, jd_id: string) {
  return fetch("/api/pipelines/run", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ resume_id, jd_id }),
  }).then((r) => r.json());
}

export function useTask(task_id?: string) {
  const shouldFetch = Boolean(task_id);
  const { data, error, isLoading } = useSWR(shouldFetch ? `/api/tasks/${task_id}` : null, fetcher, { refreshInterval: 1200 });
  return { task: data as any, error, isLoading } as const;
}
```

------

# 6) UI 对接（伪代码）

```tsx
// 调用顺序：上传 -> 解析JD -> run -> useTask轮询 -> 展示 output
const onUpload = async (file: File) => {
  const r = await uploadResume({ file });
  setResumeId(r.id);
};

const onParseJD = async (urlOrText: string) => {
  const j = await parseJD({ url: urlOrText.startsWith("http") ? urlOrText : undefined, text: !urlOrText.startsWith("http") ? urlOrText : undefined });
  setJdId(j.id);
};

const onRun = async () => {
  const t = await runPipeline(resumeId!, jdId!);
  setTaskId(t.id);
};

const { task } = useTask(taskId);
// task?.status === 'done' 时，渲染 task.output.resume_md / interview_questions / knowledge_items
```

------

# 7) TipTap SSR 报错解决（你遇到的 `immediatelyRender`）

**要点**：SSR 环境下不要让编辑器在服务端初始化；并设置 `immediatelyRender:false`。

```tsx
// 方式 A：组件级禁 SSR\ nimport dynamic from "next/dynamic";
export const ResumeEditor = dynamic(() => import("./ResumeEditorImpl"), { ssr: false });
// ResumeEditorImpl.tsx（客户端组件）
"use client";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { useEffect, useState } from "react";

export default function ResumeEditorImpl({ content }: { content: string }) {
  const [ready, setReady] = useState(false);
  useEffect(() => setReady(true), []);

  const editor = useEditor(
    () =>
      ready
        ? {
            extensions: [StarterKit],
            content,
            editorProps: { attributes: { class: "prose prose-invert" } },
            immediatelyRender: false,
          }
        : undefined,
    [ready, content]
  );

  if (!ready || !editor) return null; // or skeleton
  return <EditorContent editor={editor} />;
}
```

> 方式 B：如果必须 SSR 渲染页面，仍然让编辑器在客户端 `useEffect` 后再 mount；或用条件渲染 `isClient && <Editor/>`。

------

# 8) 真后端迁移（Prisma 模型草案）

> 保存为 `prisma/schema.prisma`

```prisma
model Resume {
  id           String   @id @default(cuid())
  raw_text     String
  skills       String[]
  contactsJson String   @default("{}")
  createdAt    DateTime @default(now())
}

model JD {
  id        String   @id @default(cuid())
  company   String
  title     String
  jd_text   String
  must      String[]
  nice      String[]
  createdAt DateTime @default(now())
}

model Output {
  id                 String   @id @default(cuid())
  resume_md          String
  interviewQuestions String[]
  knowledgeJson      String   // JSON.stringify(KnowledgeItem[])
  createdAt          DateTime @default(now())
}

model Task {
  id        String   @id @default(cuid())
  status    String
  cost      Float?
  latencyMs Int?
  outputId  String?
  createdAt DateTime @default(now())
}
```

------

# 9) LLM Provider 适配器（Qwen/DeepSeek/可扩展）

```ts
// /lib/llm.ts - 统一接口（真实接入时替换 synthesizeOutput 的实现）
export type LLMInput = { system: string; prompt: string; model: "qwen" | "deepseek" | "gpt"; temperature?: number };
export type LLMOutput = { text: string; tokens_in: number; tokens_out: number; cost: number };

export interface LLMProvider { call(input: LLMInput): Promise<LLMOutput>; }

export class QwenProvider implements LLMProvider {
  constructor(private apiKey: string) {}
  async call(i: LLMInput): Promise<LLMOutput> {
    // TODO: fetch 阿里灵积/百炼 API
    return { text: "(mock) qwen result", tokens_in: 500, tokens_out: 800, cost: 0.03 };
  }
}

export class DeepSeekProvider implements LLMProvider {
  constructor(private apiKey: string) {}
  async call(i: LLMInput): Promise<LLMOutput> {
    // TODO: fetch DeepSeek API
    return { text: "(mock) deepseek result", tokens_in: 400, tokens_out: 600, cost: 0.02 };
  }
}
```

------

# 10) 典型请求/响应样例

**上传简历**

```http
POST /api/resumes (multipart)
--boundary
Content-Disposition: form-data; name="file"; filename="cv.txt"
...
```

**响应**

```json
{ "id": "r_ab12cd34", "raw_text": "张三…", "skills": [], "parsed_blocks": [], "contacts": {} }
```

**解析 JD**

```http
POST /api/jds/parse
{"url":"https://jobs.bytedance.com/..."}
```

**响应**

```json
{ "id":"j_x9y7z1", "company":"ByteDance", "title":"后端开发工程师", "jd_text":"…", "must_have_skills":["Go","Redis","MySQL"], "nice_to_have":[] }
```

**运行流水线**

```http
POST /api/pipelines/run
{"resume_id":"r_ab12cd34","jd_id":"j_x9y7z1"}
```

**响应**

```json
{ "id":"t_88ka2p","status":"queued" }
```

**轮询任务**

```http
GET /api/tasks/t_88ka2p
```

**done 响应**

```json
{
  "id":"t_88ka2p",
  "status":"done",
  "latency_ms": 2033,
  "cost": 0.045,
  "output": {
    "id":"o_3hpq9m",
    "resume_md":"# 优化后简历…",
    "interview_questions":["…"],
    "knowledge_items":[{"title":"B 站｜A/B 测试入门","url":"https://www.bilibili.com/","why":"…"}]
  }
}
```

------

# 11) 渐进增强与上线清单（精简）

- **持久化**：从内存 → SQLite/PG（Prisma）
- **文件存储**：PDF 入 OSS/S3，本地开发用 `/tmp` 即可
- **异步任务**：开发期轮询，生产可上 Redis + BullMQ；或边缘函数 + 队列
- **观测**：Sentry + 统一日志（请求、tokens、￥）
- **限流与鉴权**：每用户 QPS、每日任务数
- **成本控制**：记录每次模型调用成本，按任务聚合成 `task.cost`

> 以上就是“一条纵向切片”的完整包：前端能拿 JSON，后端以后能平滑替换。把这些放进项目，马上就能在你的 UI 里看到 **简历草稿 + 面试问题 + 知识点** 三件套产出。



好嘞！我把完整的「契约优先 + 纵向切片」落地包（OpenAPI、TS 类型、Next API 路由 mock、前端 hooks、TipTap SSR 解决方案、Prisma 模型、LLM 适配器骨架、样例请求响应）都放到右侧画布了。你可以直接按画布里的文件顺序复制到项目里，2 分钟就能跑通**上传→解析 JD→启动任务→轮询拿三件套结果**。

快速导航（你要先做的三步）：

1. 把 `lib/types.ts`、`lib/store.ts` 放进项目。
2. 新建 4 个 API 路由：`/api/resumes`、`/api/jds/parse`、`/api/pipelines/run`、`/api/tasks/[id]`（画布有完整代码）。
3. 在你现有页面接上画布里的 `hooks`：`uploadResume` → `parseJD` → `runPipeline` → `useTask` 轮询，把 `task.output.resume_md / interview_questions / knowledge_items` 显示到你的三个面板。

顺带把你之前的 TipTap 报错也解决了：画布里给了**禁 SSR 动态导入** + `immediatelyRender:false` 的示例，照贴即可。

需要我再把这套接口生成一份 **OpenAPI → TypeScript SDK**（或直接改成 Prisma + 真库/队列版本），我也可以直接补上。